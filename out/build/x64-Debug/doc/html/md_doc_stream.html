<!-- HTML header for doxygen 1.8.7-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<title>RapidJSON: Stream</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygenextra.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="topbanner"><a href="https://github.com/Tencent/rapidjson" title="RapidJSON GitHub"><i class="githublogo"></i></a></div>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.svg"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md_doc_stream.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Stream </div></div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#MemoryStreams">Memory Streams</a><ul><li class="level2"><a href="#StringStream">StringStream (Input)</a></li>
<li class="level2"><a href="#StringBuffer">StringBuffer (Output)</a></li>
</ul>
</li>
<li class="level1"><a href="#FileStreams">File Streams</a><ul><li class="level2"><a href="#FileReadStream">FileReadStream (Input)</a></li>
<li class="level2"><a href="#FileWriteStream">FileWriteStream (Output)</a></li>
</ul>
</li>
<li class="level1"><a href="#iostreamWrapper">iostream Wrapper</a><ul><li class="level2"><a href="#IStreamWrapper">IStreamWrapper</a></li>
<li class="level2"><a href="#OStreamWrapper">OStreamWrapper</a></li>
</ul>
</li>
<li class="level1"><a href="#EncodedStreams">Encoded Streams</a><ul><li class="level2"><a href="#EncodedInputStream">EncodedInputStream</a></li>
<li class="level2"><a href="#EncodedOutputStream">EncodedOutputStream</a></li>
<li class="level2"><a href="#AutoUTFInputStream">AutoUTFInputStream</a></li>
<li class="level2"><a href="#AutoUTFOutputStream">AutoUTFOutputStream</a></li>
</ul>
</li>
<li class="level1"><a href="#CustomStream">Custom Stream</a><ul><li class="level2"><a href="#ExampleIStreamWrapper">Example: istream wrapper</a></li>
<li class="level2"><a href="#ExampleOStreamWrapper">Example: ostream wrapper</a></li>
</ul>
</li>
<li class="level1"><a href="#Summary">Summary</a></li>
</ul>
</div>
<div class="textblock"><p >In RapidJSON, <code><a class="el" href="classrapidjson_1_1_stream.html" title="Concept for reading and writing characters.">rapidjson::Stream</a></code> is a concept for reading/writing JSON. Here we'll first show you how to use provided streams. And then see how to create a custom stream.</p>
<h1><a class="anchor" id="MemoryStreams"></a>
Memory Streams</h1>
<p >Memory streams store JSON in memory.</p>
<h2><a class="anchor" id="StringStream"></a>
StringStream (Input)</h2>
<p ><code>StringStream</code> is the most basic input stream. It represents a complete, read-only JSON stored in memory. It is defined in <code><a class="el" href="rapidjson_8h.html" title="common definitions and configuration">rapidjson/rapidjson.h</a></code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span> <span class="comment">// will include &quot;rapidjson/rapidjson.h&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#a021f77051e9f85188fc2f71ff5a15ebc">StringStream</a> s(json);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.ParseStream(s);</div>
<div class="ttc" id="adocument_8h_html"><div class="ttname"><a href="document_8h.html">document.h</a></div></div>
<div class="ttc" id="anamespacerapidjson_html"><div class="ttname"><a href="namespacerapidjson.html">rapidjson</a></div><div class="ttdoc">main RapidJSON namespace</div><div class="ttdef"><b>Definition:</b> allocators.h:28</div></div>
<div class="ttc" id="anamespacerapidjson_html_a021f77051e9f85188fc2f71ff5a15ebc"><div class="ttname"><a href="namespacerapidjson.html#a021f77051e9f85188fc2f71ff5a15ebc">rapidjson::StringStream</a></div><div class="ttdeci">GenericStringStream&lt; UTF8&lt; char &gt; &gt; StringStream</div><div class="ttdoc">String stream with UTF8 encoding.</div><div class="ttdef"><b>Definition:</b> fwd.h:47</div></div>
<div class="ttc" id="anamespacerapidjson_html_ace11b5b575baf1cccd5ba5f8586dcdc8"><div class="ttname"><a href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">rapidjson::Document</a></div><div class="ttdeci">GenericDocument&lt; UTF8&lt;&gt; &gt; Document</div><div class="ttdoc">GenericDocument with UTF8 encoding.</div><div class="ttdef"><b>Definition:</b> document.h:2889</div></div>
</div><!-- fragment --><p >Since this is very common usage, <code>Document::Parse(const char*)</code> is provided to do exactly the same as above:</p>
<div class="fragment"><div class="line"><span class="comment">// ...</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span> json[] = <span class="stringliteral">&quot;[1, 2, 3, 4]&quot;</span>;</div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.Parse(json);</div>
</div><!-- fragment --><p >Note that, <code>StringStream</code> is a typedef of <code>GenericStringStream&lt;UTF8&lt;&gt; &gt;</code>, user may use another encodings to represent the character set of the stream.</p>
<h2><a class="anchor" id="StringBuffer"></a>
StringBuffer (Output)</h2>
<p ><code>StringBuffer</code> is a simple output stream. It allocates a memory buffer for writing the whole JSON. Use <code>GetString()</code> to obtain the buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/stringbuffer.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/writer.h&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ac0765ea91f41539645c4b78689d03f21">StringBuffer</a> buffer;</div>
<div class="line">Writer&lt;StringBuffer&gt; writer(buffer);</div>
<div class="line">d.Accept(writer);</div>
<div class="line"> </div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* output = buffer.GetString();</div>
<div class="ttc" id="anamespacerapidjson_html_ac0765ea91f41539645c4b78689d03f21"><div class="ttname"><a href="namespacerapidjson.html#ac0765ea91f41539645c4b78689d03f21">rapidjson::StringBuffer</a></div><div class="ttdeci">GenericStringBuffer&lt; UTF8&lt; char &gt;, CrtAllocator &gt; StringBuffer</div><div class="ttdoc">String buffer with UTF8 encoding.</div><div class="ttdef"><b>Definition:</b> fwd.h:59</div></div>
</div><!-- fragment --><p >When the buffer is full, it will increases the capacity automatically. The default capacity is 256 characters (256 bytes for UTF8, 512 bytes for UTF16, etc.). User can provide an allocator and an initial capacity.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ac0765ea91f41539645c4b78689d03f21">StringBuffer</a> buffer1(0, 1024); <span class="comment">// Use its allocator, initial size = 1024</span></div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ac0765ea91f41539645c4b78689d03f21">StringBuffer</a> buffer2(allocator, 1024);</div>
</div><!-- fragment --><p >By default, <code>StringBuffer</code> will instantiate an internal allocator.</p>
<p >Similarly, <code>StringBuffer</code> is a typedef of <code>GenericStringBuffer&lt;UTF8&lt;&gt; &gt;</code>.</p>
<h1><a class="anchor" id="FileStreams"></a>
File Streams</h1>
<p >When parsing a JSON from file, you may read the whole JSON into memory and use <code>StringStream</code> above.</p>
<p >However, if the JSON is big, or memory is limited, you can use <code>FileReadStream</code>. It only read a part of JSON from file into buffer, and then let the part be parsed. If it runs out of characters in the buffer, it will read the next part from file.</p>
<h2><a class="anchor" id="FileReadStream"></a>
FileReadStream (Input)</h2>
<p ><code>FileReadStream</code> reads the file via a <code>FILE</code> pointer. And user need to provide a buffer.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;big.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> readBuffer[65536];</div>
<div class="line">FileReadStream is(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.ParseStream(is);</div>
<div class="line"> </div>
<div class="line">fclose(fp);</div>
</div><!-- fragment --><p >Different from string streams, <code>FileReadStream</code> is byte stream. It does not handle encodings. If the file is not UTF-8, the byte stream can be wrapped in a <code>EncodedInputStream</code>. We will discuss more about this later in this tutorial.</p>
<p >Apart from reading file, user can also use <code>FileReadStream</code> to read <code>stdin</code>.</p>
<h2><a class="anchor" id="FileWriteStream"></a>
FileWriteStream (Output)</h2>
<p ><code>FileWriteStream</code> is buffered output stream. Its usage is very similar to <code>FileReadStream</code>.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filewritestream.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.Parse(json);</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// non-Windows use &quot;w&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> writeBuffer[65536];</div>
<div class="line">FileWriteStream os(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div>
<div class="line"> </div>
<div class="line">Writer&lt;FileWriteStream&gt; writer(os);</div>
<div class="line">d.Accept(writer);</div>
<div class="line"> </div>
<div class="line">fclose(fp);</div>
</div><!-- fragment --><p >It can also redirect the output to <code>stdout</code>.</p>
<h1><a class="anchor" id="iostreamWrapper"></a>
iostream Wrapper</h1>
<p >Due to users' requests, RapidJSON also provides official wrappers for <code>std::basic_istream</code> and <code>std::basic_ostream</code>. However, please note that the performance will be much lower than the other streams above.</p>
<h2><a class="anchor" id="IStreamWrapper"></a>
IStreamWrapper</h2>
<p ><code>IStreamWrapper</code> wraps any class derived from <code>std::istream</code>, such as <code>std::istringstream</code>, <code>std::stringstream</code>, <code>std::ifstream</code>, <code>std::fstream</code>, into RapidJSON's input stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="document_8h.html">rapidjson/document.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/istreamwrapper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line">ifstream ifs(<span class="stringliteral">&quot;test.json&quot;</span>);</div>
<div class="line">IStreamWrapper isw(ifs);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.ParseStream(isw);</div>
</div><!-- fragment --><p >For classes derived from <code>std::wistream</code>, use <code>WIStreamWrapper</code>.</p>
<h2><a class="anchor" id="OStreamWrapper"></a>
OStreamWrapper</h2>
<p >Similarly, <code>OStreamWrapper</code> wraps any class derived from <code>std::ostream</code>, such as <code>std::ostringstream</code>, <code>std::stringstream</code>, <code>std::ofstream</code>, <code>std::fstream</code>, into RapidJSON's input stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="document_8h.html">rapidjson/document.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/ostreamwrapper.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"><span class="keyword">using namespace </span>std;</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.Parse(json);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">ofstream ofs(<span class="stringliteral">&quot;output.json&quot;</span>);</div>
<div class="line">OStreamWrapper osw(ofs);</div>
<div class="line"> </div>
<div class="line">Writer&lt;OStreamWrapper&gt; writer(osw);</div>
<div class="line">d.Accept(writer);</div>
</div><!-- fragment --><p >For classes derived from <code>std::wostream</code>, use <code>WOStreamWrapper</code>.</p>
<h1><a class="anchor" id="EncodedStreams"></a>
Encoded Streams</h1>
<p >Encoded streams do not contain JSON itself, but they wrap byte streams to provide basic encoding/decoding function.</p>
<p >As mentioned above, UTF-8 byte streams can be read directly. However, UTF-16 and UTF-32 have endian issue. To handle endian correctly, it needs to convert bytes into characters (e.g. <code>wchar_t</code> for UTF-16) while reading, and characters into bytes while writing.</p>
<p >Besides, it also need to handle <a href="http://en.wikipedia.org/wiki/Byte_order_mark">byte order mark (BOM)</a>. When reading from a byte stream, it is needed to detect or just consume the BOM if exists. When writing to a byte stream, it can optionally write BOM.</p>
<p >If the encoding of stream is known during compile-time, you may use <code>EncodedInputStream</code> and <code>EncodedOutputStream</code>. If the stream can be UTF-8, UTF-16LE, UTF-16BE, UTF-32LE, UTF-32BE JSON, and it is only known in runtime, you may use <code>AutoUTFInputStream</code> and <code>AutoUTFOutputStream</code>. These streams are defined in <code><a class="el" href="encodedstream_8h_source.html">rapidjson/encodedstream.h</a></code>.</p>
<p >Note that, these encoded streams can be applied to streams other than file. For example, you may have a file in memory, or a custom byte stream, be wrapped in encoded streams.</p>
<h2><a class="anchor" id="EncodedInputStream"></a>
EncodedInputStream</h2>
<p ><code>EncodedInputStream</code> has two template parameters. The first one is a <code>Encoding</code> class, such as <code>UTF8</code>, <code>UTF16LE</code>, defined in <code><a class="el" href="encodings_8h_source.html">rapidjson/encodings.h</a></code>. The second one is the class of stream to be wrapped.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span>   <span class="comment">// FileReadStream</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// EncodedInputStream</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;utf16le.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> readBuffer[256];</div>
<div class="line">FileReadStream bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div>
<div class="line"> </div>
<div class="line">EncodedInputStream&lt;UTF16LE&lt;&gt;, FileReadStream&gt; eis(bis);  <span class="comment">// wraps bis into eis</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d; <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div>
<div class="line">d.ParseStream&lt;0, UTF16LE&lt;&gt; &gt;(eis);  <span class="comment">// Parses UTF-16LE file into UTF-8 in memory</span></div>
<div class="line"> </div>
<div class="line">fclose(fp);</div>
</div><!-- fragment --><h2><a class="anchor" id="EncodedOutputStream"></a>
EncodedOutputStream</h2>
<p ><code>EncodedOutputStream</code> is similar but it has a <code>bool putBOM</code> parameter in the constructor, controlling whether to write BOM into output byte stream.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;rapidjson/filewritestream.h&quot;</span>  <span class="comment">// FileWriteStream</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// EncodedOutputStream</span></div>
<div class="line"><span class="preprocessor">#include &lt;rapidjson/writer.h&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;         <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;output_utf32le.json&quot;</span>, <span class="stringliteral">&quot;wb&quot;</span>); <span class="comment">// non-Windows use &quot;w&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> writeBuffer[256];</div>
<div class="line">FileWriteStream bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div>
<div class="line"> </div>
<div class="line"><span class="keyword">typedef</span> EncodedOutputStream&lt;UTF32LE&lt;&gt;, FileWriteStream&gt; OutputStream;</div>
<div class="line">OutputStream eos(bos, <span class="keyword">true</span>);   <span class="comment">// Write BOM</span></div>
<div class="line"> </div>
<div class="line">Writer&lt;OutputStream, UTF8&lt;&gt;, UTF32LE&lt;&gt;&gt; writer(eos);</div>
<div class="line">d.Accept(writer);   <span class="comment">// This generates UTF32-LE file from UTF-8 in memory</span></div>
<div class="line"> </div>
<div class="line">fclose(fp);</div>
</div><!-- fragment --><h2><a class="anchor" id="AutoUTFInputStream"></a>
AutoUTFInputStream</h2>
<p >Sometimes an application may want to handle all supported JSON encoding. <code>AutoUTFInputStream</code> will detection encoding by BOM first. If BOM is unavailable, it will use characteristics of valid JSON to make detection. If neither method success, it falls back to the UTF type provided in constructor.</p>
<p >Since the characters (code units) may be 8-bit, 16-bit or 32-bit. <code>AutoUTFInputStream</code> requires a character type which can hold at least 32-bit. We may use <code>unsigned</code>, as in the template parameter:</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="document_8h.html">rapidjson/document.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/filereadstream.h&quot;</span>   <span class="comment">// FileReadStream</span></div>
<div class="line"><span class="preprocessor">#include &quot;rapidjson/encodedstream.h&quot;</span>    <span class="comment">// AutoUTFInputStream</span></div>
<div class="line"><span class="preprocessor">#include &lt;cstdio&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line">FILE* fp = fopen(<span class="stringliteral">&quot;any.json&quot;</span>, <span class="stringliteral">&quot;rb&quot;</span>); <span class="comment">// non-Windows use &quot;r&quot;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">char</span> readBuffer[256];</div>
<div class="line">FileReadStream bis(fp, readBuffer, <span class="keyword">sizeof</span>(readBuffer));</div>
<div class="line"> </div>
<div class="line">AutoUTFInputStream&lt;unsigned, FileReadStream&gt; eis(bis);  <span class="comment">// wraps bis into eis</span></div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;         <span class="comment">// Document is GenericDocument&lt;UTF8&lt;&gt; &gt; </span></div>
<div class="line">d.ParseStream&lt;0, AutoUTF&lt;unsigned&gt; &gt;(eis); <span class="comment">// This parses any UTF file into UTF-8 in memory</span></div>
<div class="line"> </div>
<div class="line">fclose(fp);</div>
</div><!-- fragment --><p >When specifying the encoding of stream, uses <code>AutoUTF&lt;CharType&gt;</code> as in <code>ParseStream()</code> above.</p>
<p >You can obtain the type of UTF via <code>UTFType GetType()</code>. And check whether a BOM is found by <code>HasBOM()</code></p>
<h2><a class="anchor" id="AutoUTFOutputStream"></a>
AutoUTFOutputStream</h2>
<p >Similarly, to choose encoding for output during runtime, we can use <code>AutoUTFOutputStream</code>. This class is not automatic <em>per se</em>. You need to specify the UTF type and whether to write BOM in runtime.</p>
<div class="fragment"><div class="line"><span class="keyword">using namespace </span><a class="code hl_namespace" href="namespacerapidjson.html">rapidjson</a>;</div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">void</span> WriteJSONFile(FILE* fp, UTFType type, <span class="keywordtype">bool</span> putBOM, <span class="keyword">const</span> <a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a>&amp; d) {</div>
<div class="line">    <span class="keywordtype">char</span> writeBuffer[256];</div>
<div class="line">    FileWriteStream bos(fp, writeBuffer, <span class="keyword">sizeof</span>(writeBuffer));</div>
<div class="line"> </div>
<div class="line">    <span class="keyword">typedef</span> AutoUTFOutputStream&lt;unsigned, FileWriteStream&gt; OutputStream;</div>
<div class="line">    OutputStream eos(bos, type, putBOM);</div>
<div class="line">    </div>
<div class="line">    Writer&lt;OutputStream, UTF8&lt;&gt;, AutoUTF&lt;&gt; &gt; writer;</div>
<div class="line">    d.Accept(writer);</div>
<div class="line">}</div>
</div><!-- fragment --><p ><code>AutoUTFInputStream</code> and <code>AutoUTFOutputStream</code> is more convenient than <code>EncodedInputStream</code> and <code>EncodedOutputStream</code>. They just incur a little bit runtime overheads.</p>
<h1><a class="anchor" id="CustomStream"></a>
Custom Stream</h1>
<p >In addition to memory/file streams, user can create their own stream classes which fits RapidJSON's API. For example, you may create network stream, stream from compressed file, etc.</p>
<p >RapidJSON combines different types using templates. A class containing all required interface can be a stream. The Stream interface is defined in comments of <code><a class="el" href="rapidjson_8h.html" title="common definitions and configuration">rapidjson/rapidjson.h</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">concept </span><a class="code hl_class" href="classrapidjson_1_1_stream.html">Stream</a> {</div>
<div class="line">    typename Ch;    <span class="comment">//!&lt; Character type of the stream.</span></div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Read the current character from stream without moving the read cursor.</span></div>
<div class="line"><span class="comment"></span>    Ch Peek() const;</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Read the current character from stream and moving the read cursor to next character.</span></div>
<div class="line"><span class="comment"></span>    Ch Take();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Get the current read cursor.</span></div>
<div class="line"><span class="comment">    //! \return Number of characters read from start.</span></div>
<div class="line"><span class="comment"></span>    size_t Tell();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Begin writing operation at the current read pointer.</span></div>
<div class="line"><span class="comment">    //! \return The begin writer pointer.</span></div>
<div class="line"><span class="comment"></span>    Ch* PutBegin();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Write a character.</span></div>
<div class="line"><span class="comment"></span>    void Put(Ch c);</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! Flush the buffer.</span></div>
<div class="line"><span class="comment"></span>    void Flush();</div>
<div class="line"><span class="comment"></span> </div>
<div class="line"><span class="comment">    //! End the writing operation.</span></div>
<div class="line"><span class="comment">    //! \param begin The begin write pointer returned by PutBegin().</span></div>
<div class="line"><span class="comment">    //! \return Number of characters written.</span></div>
<div class="line"><span class="comment"></span>    size_t PutEnd(Ch* begin);</div>
<div class="line">}</div>
<div class="ttc" id="aclassrapidjson_1_1_stream_html"><div class="ttname"><a href="classrapidjson_1_1_stream.html">Stream</a></div><div class="ttdoc">Concept for reading and writing characters.</div></div>
</div><!-- fragment --><p >For input stream, they must implement <code>Peek()</code>, <code>Take()</code> and <code>Tell()</code>. For output stream, they must implement <code>Put()</code> and <code>Flush()</code>. There are two special interface, <code>PutBegin()</code> and <code>PutEnd()</code>, which are only for <em>in situ</em> parsing. Normal streams do not implement them. However, if the interface is not needed for a particular stream, it is still need to a dummy implementation, otherwise will generate compilation error.</p>
<h2><a class="anchor" id="ExampleIStreamWrapper"></a>
Example: istream wrapper</h2>
<p >The following example is a simple wrapper of <code>std::istream</code>, which only implements 3 functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyIStreamWrapper {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> Ch;</div>
<div class="line"> </div>
<div class="line">    MyIStreamWrapper(std::istream&amp; is) : is_(is) {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Ch Peek()<span class="keyword"> const </span>{ <span class="comment">// 1</span></div>
<div class="line">        <span class="keywordtype">int</span> c = is_.peek();</div>
<div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (Ch)c;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Ch Take() { <span class="comment">// 2</span></div>
<div class="line">        <span class="keywordtype">int</span> c = is_.get();</div>
<div class="line">        <span class="keywordflow">return</span> c == std::char_traits&lt;char&gt;::eof() ? <span class="charliteral">&#39;\0&#39;</span> : (Ch)c;</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> (<span class="keywordtype">size_t</span>)is_.tellg(); } <span class="comment">// 3</span></div>
<div class="line"> </div>
<div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div>
<div class="line">    <span class="keywordtype">void</span> Put(Ch) { assert(<span class="keyword">false</span>); }</div>
<div class="line">    <span class="keywordtype">void</span> Flush() { assert(<span class="keyword">false</span>); }</div>
<div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    MyIStreamWrapper(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div>
<div class="line">    MyIStreamWrapper&amp; operator=(<span class="keyword">const</span> MyIStreamWrapper&amp;);</div>
<div class="line"> </div>
<div class="line">    std::istream&amp; is_;</div>
<div class="line">};</div>
</div><!-- fragment --><p >User can use it to wrap instances of <code>std::stringstream</code>, <code>std::ifstream</code>.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* json = <span class="stringliteral">&quot;[1,2,3,4]&quot;</span>;</div>
<div class="line">std::stringstream ss(json);</div>
<div class="line">MyIStreamWrapper is(ss);</div>
<div class="line"> </div>
<div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line">d.ParseStream(is);</div>
</div><!-- fragment --><p >Note that, this implementation may not be as efficient as RapidJSON's memory or file streams, due to internal overheads of the standard library.</p>
<h2><a class="anchor" id="ExampleOStreamWrapper"></a>
Example: ostream wrapper</h2>
<p >The following example is a simple wrapper of <code>std::istream</code>, which only implements 2 functions.</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyOStreamWrapper {</div>
<div class="line"><span class="keyword">public</span>:</div>
<div class="line">    <span class="keyword">typedef</span> <span class="keywordtype">char</span> Ch;</div>
<div class="line"> </div>
<div class="line">    MyOStreamWrapper(std::ostream&amp; os) : os_(os) {</div>
<div class="line">    }</div>
<div class="line"> </div>
<div class="line">    Ch Peek()<span class="keyword"> const </span>{ assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div>
<div class="line">    Ch Take() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> <span class="charliteral">&#39;\0&#39;</span>; }</div>
<div class="line">    <span class="keywordtype">size_t</span> Tell()<span class="keyword"> const </span>{  }</div>
<div class="line"> </div>
<div class="line">    Ch* PutBegin() { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div>
<div class="line">    <span class="keywordtype">void</span> Put(Ch c) { os_.put(c); }                  <span class="comment">// 1</span></div>
<div class="line">    <span class="keywordtype">void</span> Flush() { os_.flush(); }                   <span class="comment">// 2</span></div>
<div class="line">    <span class="keywordtype">size_t</span> PutEnd(Ch*) { assert(<span class="keyword">false</span>); <span class="keywordflow">return</span> 0; }</div>
<div class="line"> </div>
<div class="line"><span class="keyword">private</span>:</div>
<div class="line">    MyOStreamWrapper(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div>
<div class="line">    MyOStreamWrapper&amp; operator=(<span class="keyword">const</span> MyOStreamWrapper&amp;);</div>
<div class="line"> </div>
<div class="line">    std::ostream&amp; os_;</div>
<div class="line">};</div>
</div><!-- fragment --><p >User can use it to wrap instances of <code>std::stringstream</code>, <code>std::ofstream</code>.</p>
<div class="fragment"><div class="line"><a class="code hl_typedef" href="namespacerapidjson.html#ace11b5b575baf1cccd5ba5f8586dcdc8">Document</a> d;</div>
<div class="line"><span class="comment">// ...</span></div>
<div class="line"> </div>
<div class="line">std::stringstream ss;</div>
<div class="line">MyOStreamWrapper os(ss);</div>
<div class="line"> </div>
<div class="line">Writer&lt;MyOStreamWrapper&gt; writer(os);</div>
<div class="line">d.Accept(writer);</div>
</div><!-- fragment --><p >Note that, this implementation may not be as efficient as RapidJSON's memory or file streams, due to internal overheads of the standard library.</p>
<h1><a class="anchor" id="Summary"></a>
Summary</h1>
<p >This section describes stream classes available in RapidJSON. Memory streams are simple. File stream can reduce the memory required during JSON parsing and generation, if the JSON is stored in file system. Encoded streams converts between byte streams and character streams. Finally, user may create custom streams using a simple interface. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.7-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
  </ul>
</div>
</body>
</html>
